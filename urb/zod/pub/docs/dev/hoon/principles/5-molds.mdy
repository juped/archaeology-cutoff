---
title: Hoon 101.5: from mold to span
sort: 5
next: false
---
# Hoon 101.5: from mold to span

In [chapter 0](0-nouns), we read about nouns.  In [chapter 1](1-twigs), 
we discovered twigs and legs.  In [chapter 2](2-syntax), we learned 
Hoon syntax and created our first source file.  In [chapter 3](3-algorithm) 
we wrote an actual algorithm.  And in [chapter 4](4-function) we
went so far as to define a function.

Now we'll go crazy and build some actual *data structures*.

## How to use this tutorial

Ideally, you've installed an Urbit planet (if you have a ticket)
or comet (if you don't).  See the [user doc](../../../user).

We recommend opening up the dojo and just typing the examples;
you don't know a language until you know it in your fingers.
Also, make sure you've worked through the chapters in order.

## Goal: practical data structures

Having built functions, our next goal is *data structures*.  We
know this involves molds and spans, somehow.  We'd like to
actually put our data structures in structure files our build
system can use, as though we were really writing a programs.

## Form of the solution: books and reef

Our solution comes in a new subspecies of core: the *book*.

If a gate is a function, a book is a library.  (Saying "library"
instead of "book" is even more inaccurate than calling a gate a
"function", but people will do it.)  A book is just a core which 
pushes no payload data and can have any arms it wants.

> Cores earn these labels by their payload geometry and/or
battery constraints.  A *gate* has payload geometry `[sample
context]` and a one-arm battery, `$`.  A *book* has no payload
geometry or battery constraints.  A core with a payload `[sample
context]`, but no battery constraints, is a *door*.  A core with
no payload geometry, but a one-arm battery `$`, is a *trap*.

A conventional Hoon subject, which does the job carried out by an
scope, environment or context, is a big stack of books called a
*reef*.  Each book's payload is the book above it.  Outer code
can use inner code, but not of course the reverse.

There are many ways to assemble a reef of books, but written
straight out in one file, with the simplest possible runes:
```
=>  zero=0
=>  |%
    ++  one  zero
    --
=>  |%
    ++  two  +(one)
    --
|%
++  tri  +(two)
--
```
This produces a core noun that looks like:
```
[tri-battery two-battery one-battery zero=0]
```

## Reef structures

When we build user-level code in practice, we use the Arvo build
system `%ford` (which also built our generator in the last
chapter).

The user-level reef you get in `%ford` contains, in order: the
Hoon system (the basic books we need to build the compiler, then
the compiler, then all the standard books we don't need to build
the compiler but should be bundled in Arvo); then, a book of
data structures; then, a book of libraries.

System-level arms are naked -- you don't write `(dec:system 42)`
to decrement `42`, you write `(dec 42)`.  But user-level books,
for both libraries and structures, are actually books of books.
Your structure book is shaped like:
```
|%  
++  book-one
  |%
  ++  one  0
  --
++  book-two
  |%
  ++  two  +(one:book-one)
  --
++  book-tri
  |%
  ++  tri  +(two:book-two)
  --
--
```
Since this chapter is about molds, we'll be installing and
loading a structure file, containing a single structure book.
You can even think of this as an "include file" if you like.

A structure book named `/test`, in the `%sandbox` desk, goes in
`/=sandbox=/sur/test/hoon`.  In Unix, this will be
`tasfyn-partyv/sur/test.hoon`, as soon as you mount `%sur`:
```
~tasfyn-partyv:dojo/sandbox> |mount /===/sur %sur
```
Let's do everything properly this time.  At the top of the file, 
put the standard Hoon block-comment header:
```
::                                                      ::  ::
::::  /hoon/test/sur                                    ::::::  test structures
  ::                                                    ::  ::
```
> Nothing in these lines is parsed, of course.  But its presence
and standard form shows the reader you care about writing tight,
pro-quality Hoon.  Its absence shows the opposite -- which may
be perfectly fine.  (Why is the path backward?  Because it is.
The stylized N at column 0 is for Nock; the H at 57 is for Hoon.
Apparently it's called "branding" and is still done to cows.)

After this decorative header, our file is just the book itself.
There is no more boilerplate.
```
|%
++  welcome  ,[%hello %world]
--
```
> Hoon can become quite gnarly, but only if you're doing
something wrong.  If your Hoon gets gnarly, you are either
choosing the wrong solution or solving the wrong problem.
Normal code should be quite pretty.

## Loading a structure file

We've created a tiny, tasteful little structure book.  Let's fire
it up.  At the dojo prompt:
```
~tasfyn-partyv:dojo/sandbox> =+sur /test
```
This puts our `test` book into the structure book that the dojo
uses when it builds each and every command line.
```
~tasfyn-partyv:dojo/sandbox> *welcome:test
  [%hello %world]
```
You've just built and used your first mold.

## Types in Hoon: span and mold revisited

While Hoon is a higher-order typed functional language like
Haskell, its type system works on very different principles
than Haskell's.  Or Java's.  Or any normal language's.

One concept in a normal language, the *type*, becomes two quite
categorically different concepts in Hoon, the *mold* and *span*.

> This blatant complication appears to violate Occam's razor.
But Einstein, who was based, said: everything must be as simple
as possible, but no simpler.  Also, once you've seen the
difference between a mold and a span, it's hard to unsee it.

Spans we've already done a lot of work with.  What is a span?  We
know the answer now: a *semantically annotated set of nouns*.

Whereas a mold is a *constructive definition of noun geometry*.
It's easy to see how in most languages, these are synonyms.

## Intuitive molds

"A mold is a constructive definition of a noun geometry."  Let's
make this sentence make sense.

A mold, like a span, defines a noun geometry.  The mold expresses
its semantics by expanding itself to a twig that, applied to an
arbitrary subject, produces a noun within the geometry.

The molded twig is a *normalizer*.  If its subject is within its
range, it produces its own subject.  In math notation, `f(f(x))
== f(x)`.

For example, consider one simple shape: a pair of atoms.  A
normalizer for this shape is:
```
?:(.?(+1) [0 0] [?:(.?(+2) 0 +2) ?:(.?(+3) 0 +3)])
```
If the subject is a pair of atoms, the product is the subject.
Otherwise, we apply `0` as necessary to produce a pair of atoms.
(A normalizer can also crash on bad input instead of fixing it.)

So molds construct twigs.  Then twig compilation maps `[span
twig]`, the subject set and the source expression, to `[span
nock]`, the product set and Nock formula.

Not only are molds and spans categorically different, they never
even touch each other.  Molds are a macro system; spans are an
inference engine.

So a mold is a constructive definition of a noun geometry,
because it constructs a twig which applies its geometry.  Does
this make more sense now?

## Deeper into molds

Molds are a beautiful thing in principle.  But we have to admit
that mold syntax and naming are the gnarliest corners of Hoon.
(Of course, that's only because the rest is so chic.) 

The previous section is a correct, but abstract, definition of a
mold.  The truth about molds is that we use them to generate two
more specific twigs: the `bunt` and the `clam`.

> We apologize again for these atrocious names.  In particular,
nothing smells worse than a rotten clam.

The `bunt` of a mold is a twig that produces a default noun
(hopefully, but not always, constant) in the mold geometry.

The `clam` of a mold is a twig that produces a gate, whose sample
is any noun, and whose product is in the mold geometry.

In our example above, we bunted with the syntax `*welcome:test`.
(Regular form: `$*($^(welcome:test))`.)  This twig produced the
only noun, `[%hello %world]`, in the geometry.

But `++welcome` itself is defined as `,[%hello %world]`.
(Regular form: `$,($:(%hello %world))`.)  This twig produces a
gate whose product is always `[%hello %world]`:
```
~tasfyn-partyv:dojo/sandbox> (welcome:test ~)
[%hello %world]
~tasfyn-partyv:dojo/sandbox> (welcome:test %hello %world)
[%hello %world]
~tasfyn-partyv:dojo/sandbox> (welcome:test %world %hello ~)
[%hello %world]
```

## The `mold` mold

You don't know all this syntax yet, but:
```
++  mold  $&  [p=mold q=mold]                     ::  ordered pair
          $%  [%axil p=base]                      ::  base type
              [%bark p=term q=mold]               ::  name
              [%bush p=mold q=mold]               ::  pair/tag
              [%fern p=[i=mold t=(list mold)]]    ::  plain selection
              [%herb p=twig]                      ::  gate
              [%kelp p=[i=line t=(list line)]]    ::  tag selection
              [%leaf p=term q=@]                  ::  constant atom
              [%reed p=mold q=mold]               ::  atom/cell
              [%weed p=twig]                      ::  example
          ==                                      ::
```
Although we use normal Hoon rune syntax to parse molds, we name
the mold stems not by the rune names `%tsls` style, but rather
with this strange herbaceous motif.

> Some think the only reason molds have wordy stems is to
prove what a bad idea it'd be to use this style for twigs.

## Twigs and molds: a complicated relationship

Alas, we've misled you a little in our definition of a twig.

You may have thought twigs were a homogeneously recursive tree.
Different stems may have different fanout in their bulbs, like
the difference between `[%tsls p=twig q=twig]` and `[%cltr
p=(list twig)]`, but at least everything repeated was a twig.

Not so.  Some twigs contain molds, like `[%wtts p=mold q=twig]`.
Some molds contain twigs, like `[%weed p=twig]`.  It's a regular
rainforest out there.  In this jungle, Hoon's syntax has to be
optimized for prettiness rather than clarity, a mistake we don't
like to make.  Some confusion is the inevitable consequence.

For example, look at `,[%hello %world]`.  This is a twig, whose
simplest regular form is `$,([%hello %world])`.  `$,` is a twig
`[%bccm p=mold]`; it produces the clam of `p`.

So in this context, `[%hello %world]` is a mold.  It's an
irregular form of the mold `$:(%hello %world)`, which parses to
`[[%leaf %tas %hello] [%leaf %tas %world]]`.

This same syntax, `[%hello %world]`, is perfectly good *twig*
syntax.  So it's easy to write `[%hello %world]` instead of
`,[%hello %world]`.  They're both twigs, but *different* twigs.

When we write `*welcome:test`, or formally `$*(welcome:test)`, 
again we write a twig: `[%bctr p=mold]`.  So `welcome:test` is a
mold?  We thought it was a twig?  It's both, and this time it
means the *same* thing.

When you use a twig where a mold belongs, the parser assumes your
twig is a normalizing gate.  It automatically inserts the `%herb`
stem, `$^`.  Again, the full regular syntax: `$*($^(welcome:test))`.

Of course, `welcome:test` *is* a normalizing gate.  Because the
`welcome` arm produces a clam `$,`, which as we just saw makes
the mold `[%hello %world]` into a normalizing gate.  So it's all
good, really.  But it's pretty confusing for two lines of code!

It's easy to focus too much on these conundrums and get even more
confused.  But molds are the most confusing aspect of Hoon, and
the twig-mold relationship is the most confusing aspect of molds.
And honestly, it's really not that difficult.


