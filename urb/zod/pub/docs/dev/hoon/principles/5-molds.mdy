---
title: Hoon 101.5: from mold to span
sort: 5
next: false
---
# Hoon 101.5: from mold to span

In [chapter 0](0-nouns), we read about nouns.  In [chapter 1](1-twigs), 
we discovered twigs and legs.  In [chapter 2](2-syntax), we learned 
Hoon syntax and created our first source file.  In [chapter 3](3-algorithm) 
we wrote an actual algorithm.  And in [chapter 4](4-function) we
went so far as to define a function.

Now we'll go crazy and build some actual *data structures*.

## How to use this tutorial

Ideally, you've installed an Urbit planet (if you have a ticket)
or comet (if you don't).  See the [user doc](../../../user).

We recommend opening up the dojo and just typing the examples;
you don't know a language until you know it in your fingers.
Also, make sure you've worked through the chapters in order.

## Goal: practical data structures

Having built functions, our next goal is *data structures*.  We
know this involves molds and spans, somehow.  We'd like to
actually put our data structures in structure files our build
system can use, as though we were really writing a programs.

## Form of the solution: books and reef

Our solution comes in a new subspecies of core: the *book*.  If a
gate is a sort of function, a book is a sort of library.  In the 

> Cores earn their labels by their payload geometry and/or
battery constraints.  A *gate* has payload geometry `[sample
context]` and a one-arm battery, `$`.  A *book* has no payload
geometry or battery constraints.  A core with a payload `[sample
context]`, but no battery constraints, is a *door*.  A core with
no payload geometry, but a one-arm battery `$`, is a *trap*.

A conventional Hoon subject, which does the job carried out by an
scope, environment or context, is a big stack of books called a
*reef*.  Each book's payload is the book above it.  Outer code
can use inner code, but not of course the reverse.

There are many ways to assemble a reef of books, but written
straight out in one file, with the simplest possible runes:
```
=>  zero=0
=>  |%
    ++  one  zero
    --
=>  |%
    ++  two  +(one)
    --
|%
++  tri  +(two)
--
```
This produces a reef that looks like:
```
[tri-battery two-battery one-battery zero=0]
```
Obviously, from the third book you can use arms in all three
books.  In the second book you can use the second and first.
In the first you can only use the first.

## Reef structure and meta-books

When we build user-level code in practice, we use the Arvo build
system `%ford` (which also built our generator in the last
chapter).

The user-level reef you get in `%ford` contains, in order: the
Hoon system (the books that we need to build the compiler; then
the compiler; then the books that we don't need to build the
compiler, but everyone should still have); then, a meta-book of
user-level data structures; then, a meta-book of user-level
algorithms.

A meta-book is just a book whose arms produce books.  System arms
are naked.  You don't write `(dec:system 42)` to decrement `42`,
you write `(dec 42)`.  But user-level books, for both libraries
and structures, are actually books of books.  Your user-level
structure book is shaped like: 
``` 
|%  
++  book-one
  |%
  ++  one  0
  --
++  book-two
  |%
  ++  two  +(one:book-one)
  --
++  book-tri
  |%
  ++  tri  +(two:book-two)
  --
--
```
Since this chapter is about molds, we'll be installing and
loading a structure file, containing a single structure book.
You can even think of this as an "include file" if you like.

A structure book named `/test`, in the `%sandbox` desk, goes in
`/=sandbox=/sur/test/hoon`.  In Unix, this will be
`tasfyn-partyv/sur/test.hoon`, as soon as you mount `%sur`:
```
~tasfyn-partyv:dojo/sandbox> |mount /===/sur %sur
```
Let's do everything properly this time.  At the top of the file, 
put the standard Hoon block-comment header:
```
::                                                      ::  ::
::::  /hoon/test/sur                                    ::::::  test structures
  ::                                                    ::  ::
```
> Nothing in this header is parsed, of course.  But its presence
and standard form shows the reader you care about writing tight,
pro-quality Hoon.  Its absence shows the opposite -- which may
be perfectly fine.  (Why is the path backward?  Because it is.
The stylized N at column 0 is for Nock; the H at 57 for Hoon.)

After this decorative header, our file is just the book itself.
There is no more boilerplate.
```
|%
++  welcome  ,[%hello %world]
--
```

## Loading a structure file

We've created a tiny, tasteful little structure book.  Let's fire
it up.  At the dojo prompt:
```
~tasfyn-partyv:dojo/sandbox> =+sur /test
```
This puts our `test` book into the structure book that the dojo
uses when it builds each and every command line.
```
~tasfyn-partyv:dojo/sandbox> *welcome:test
  [%hello %world]
```
You've just built and used your first mold.  But wait, what are
we doing here?

## Types in Hoon: span and mold revisited

While Hoon is a higher-order typed functional language like
Haskell, its type system works on very different principles
than Haskell's.  Or Java's.  Or any normal language's.

One concept in a normal language, the *type*, becomes two quite
different concepts in Hoon, the *mold* and *span*.

Spans we've already done a lot of work with.  What is a span?  We
know the answer now: a *semantically annotated set of nouns*.

Whereas a mold is a *constructive definition of noun geometry*.
It's easy to see how in most languages, these are synonyms.  But
in Hoon, a mold is a way to make a noun; a span is a way to
describe the noun you've made.

## Intuitive molds

"A mold is a constructive definition of a noun geometry."  Let's
make this sentence make sense.

A mold, like a span, defines a noun geometry.  The mold expresses
its semantics by expanding itself to a twig that, applied to an
arbitrary subject, produces a correctly-shaped noun.

The molded twig is a *normalizer*.  If its subject is within its
range, it produces its own subject.  In math notation, `f(f(x))
== f(x)`.  If its subject is out of range, it makes a default.

For example, consider one simple shape: a pair of atoms.  A
normalizer for this shape is:
```
?:(.?(+1) [0 0] [?:(.?(+2) 0 +2) ?:(.?(+3) 0 +3)])
```
If the subject is a pair of atoms, the product is the subject.
Otherwise, we default as necessary to produce a pair of atoms.

So molds construct twigs.  Then twig compilation maps `[span
twig]`, the subject set and the source expression, to `[span
nock]`, the product set and Nock formula.

Not only are molds and spans categorically different, they never
even touch each other.  Molds are a macro system; spans are an
inference engine.

So a mold is a constructive definition of a noun geometry,
because it constructs a twig which applies its geometry.  Does
this make more sense now?

## Molds as twigs

Is a mold a twig?  If not, how do we put it in a Hoon file?

A mold is not a twig, though it uses twig-like syntax.  We wrap
it in a twig in one of two ways: a `bunt` or a `clam`.

The `bunt` of a mold is a twig that produces a default noun
(hopefully, but not always, constant) in the mold geometry.
The regular bunt form is `$*(mold)`; irregular form, `*mold`.

The `clam` of a mold is a twig that produces a gate, whose sample
is any noun, and whose product is in the mold geometry.  The
regular clam form is `$,(mold)`; irregular form, `,mold`.

It's easy to get from normalizer to bunt: just normalize nil,
`~`.  It's easy to get from normalizer to clam: just make a gate
whose sample is `*`, any noun, and normalize the sample.

## The mold for molds

Obviously, this uses mold syntax that we haven't explained yet,
but here's 
Now that you're thoroughly frightened, let's go through our molds
one by one and 

```
++  base  ?([%atom p=odor] %noun %cell %bean %null)     ::  axils, @ * ^ ? ~
++  line  ,[p=[%leaf p=@tas q=@] q=tile]          ::  %kelp case
++  mold  $&  [p=mold q=mold]                     ::  ordered pair
          $%  [%axil p=base]                      ::  base type
              [%bark p=term q=mold]               ::  name
              [%bush p=mold q=mold]               ::  pair/tag
              [%fern p=[i=mold t=(list mold)]]    ::  plain selection
              [%herb p=twig]                      ::  gate
              [%kelp p=[i=line t=(list line)]]    ::  tag selection
              [%leaf p=term q=@]                  ::  constant atom
              [%reed p=mold q=mold]               ::  atom/cell
              [%weed p=twig]                      ::  example
          ==                                      ::
```
Although we use normal Hoon rune syntax to parse molds, we name
the mold stems with this herbal theme, not condensed rune names.

## Understanding our example

Currently in `sur/test/hoon` we have:
```
|%
++  welcome  ,[%hello %world]
--
```


Molds are a beautiful thing in principle.  But we have to admit
that mold syntax and naming are the gnarliest corners of Hoon.
(Of course, that's only because the rest is so elegant.) 

The previous section is a correct, but abstract, definition of a
mold.  The truth about molds is that we use them to generate two
more specific twigs: the `bunt` and the `clam`.

> We apologize again for these atrocious names.  In particular,
nothing smells worse than a rotten clam.

In our example above, we bunted with the syntax `*welcome:test`.
(Regular form: `$*($^(welcome:test))`.)  This twig produced the
only noun, `[%hello %world]`, in the geometry.

But `++welcome` itself is defined as `,[%hello %world]`.
(Regular form: `$,($:(%hello %world))`.)  This twig produces a
gate whose product is always `[%hello %world]`:
```
~tasfyn-partyv:dojo/sandbox> (welcome:test ~)
[%hello %world]
~tasfyn-partyv:dojo/sandbox> (welcome:test %hello %world)
[%hello %world]
~tasfyn-partyv:dojo/sandbox> (welcome:test %world %hello ~)
[%hello %world]
```

---------------------UNMERGED-----------------


The mold's raw input is called its *pronoun*.  A twig computes
its product from its subject.  A mold rectifies its pronoun
(an arbitrary noun) into the *surnoun* (a well-shaped noun).

Here is the mold of `mold`.  We don't know all this syntax yet.
Let's try not to depend on features before we've defined them.
```
++  mold  $&  [p=mold q=mold]                     ::  ordered pair
          $%  [%axil p=base]                      ::  base type
              [%bark p=term q=mold]               ::  name
              [%bush p=mold q=mold]               ::  pair/tag
              [%cane p=mold q=mold]               ::
              [%fern p=[i=mold t=(list mold)]]    ::  plain selection
              [%herb p=twig]                      ::  gate
              [%kelp p=[i=line t=(list line)]]    ::  tag selection
              [%leaf p=@tas q=@]                  ::  constant atom
              [%reed p=mold q=mold]               ::  atom/cell
              [%weed p=twig]                      ::  example
          ==                                      ::
```



### `[%leaf p=@tas q=@]`: an atomic constant

A `%leaf` mold, like `%hello`, builds a constant atom.
`q` is the atom; `p` is the aura.

> Wait: isn't `%hello` also a twig?  Yes.  Since the parser knows
when it's parsing a twig or a mold, twig and mold syntax freely
overlaps.  When these syntaxes match, we try to make them mean
the same *abstract* concept, but they're still different things.

We already have a leaf in our test book, but let's add `%hello`
to it:
```
|%
++  hello    ,%hello
++  welcome  ,[hello %world]
--
```
Now we can use `hello` the way we used `welcome`:
```
~tasfyn-partyv:dojo/sandbox> *hello
  %hello
~tasfyn-partyv:dojo/sandbox> (hello 42)
  %hello
```
### `[p=mold q=mold]`: a parallel pair

Molds use the same geometric trick as twigs and Nock formulas:
binding pair semantics to a stemless bulb.  But mold and twig
pair semantics are very different.

In a twig pair, of course, head and tail use the same subject.
In a mold pair, the pronoun *splits in half*.  The head mold
rectifies the pronoun's head; the tail mold rectifies its tail.
If the pronoun is an atom, it's defaulted to `[0 0]`.

<<<<<<< HEAD
The regular syntax for a mold tuple is `$:(a b c)`, but the
irregular form is `[a b c]`, matching the twig syntax.  (The
regular form of a twig tuple is `:*(a b c)`.)

Let's modify our test book to use only regular forms:
```
|%
++  hello    $,  %hello
++  welcome  $,  $:(hello %world)
--
```
### `[%herb p=twig]`: gate as mold

Our test book is actually *almost* regular.  For complete
regularity, we need to use a very rare rune, `$^`:
```
|%
++  hello    $,  %hello
++  welcome  $,  $:($^(hello) %world)
--
```
The irregular form of `$^(hello)` is just `hello`.  When Hoon is
trying to parse a mold and fails, it tries to parse a twig
instead.  If that succeeds, it's wrapped in an invisible `$^` as
an `%herb`.  We only need to type the `$^` if our twig's syntax
actually parses as a mold, which is basically never.

How does an `%herb` work?  The twig `p` is a gate (a function).  To
produce the surnoun, we slam (call) `p` on the pronoun.

> When we use a twig as a mold, in both `%herb` and `%weed`,
what's the subject of the twig?  The same as the subject of the
twig rune, eg `$*` or `$,`, that we use the mold in.  In other
words, molds remain hygienic in the Lisp macro sense.

As we see, the relationship between twigs and molds can get quite
intricate, even when the code looks simple.  Let's expand our
test file to put arms, twigs and molds on separate lines:
```
|%                            ::  twig
++  hello                     ::  arm
             $,               ::  twig
               %hello         ::  mold
++  welcome                   ::  arm
             $,               ::  twig
               $:             ::  mold
                 $^           ::  mold
                   hello      ::  twig
                 %world       ::  mold
               ==
--
```
### `[%weed p=twig]`

`%weed` also uses a twig `p` as a mold.  But `p` in an `%herb` is
a rectifier; `p` in a twig is just an example.  To produce the
surnoun, we just apply `p`, ignoring the pronoun.

Just to be contrary, let's build `%world` as a weed.  The regular
syntax is `$_(%world)`; the irregular form is `_%world`.  We'll
add it to our regular test book:
```
|%                            ::  twig
++  hello                     ::  arm
             $,               ::  twig
               %hello         ::  mold
++  welcome                   ::  arm
             $,               ::  twig
               $:             ::  mold
                 $^           ::  mold
                   hello      ::  twig
                 $_           ::  mold
                   world      ::  twig
               ==             :: 
++  world                     ::  arm
            %world            ::  twig
--
```
Staring at this illustration for a few minutes might leave you
with a little more grounding on the twig-mold relationship.  The
same code, back in irregular form:
```
|%
++  hello    ,%hello
++  welcome  ,[hello _world]
++  world    %world
--
```
As the name implies, `%weed` is generally little disreputale.

###
