::                                                      ::  ::
::::  /hook/core/acto/ape                               ::  ::  dependencies
  ::                                                    ::  ::
/?  310                                                 ::  arvo version
/-  *sole, *octo                                        ::  structures
/+  sole, octo                                          ::  libraries
::                                                      ::  ::
::::                                                    ::  ::  structures
  !:                                                    ::  ::
=>  |%                                                  ::  arvo structures
    ++  axle  ,[eye=face but=(unit ship) gam=game]      ::  agent state
    ++  card  $%  [%diff lime]                          ::  update
                  [%quit ~]                             ::  cancel
                  [%peer wire dock path]                ::  subscribe
                  [%poke wire dock pear]                ::  send move
                  [%pull wire dock ~]                   ::  unsubscribe
              ==                                        ::
    ++  face  (pair (list ,@c) (map bone sole-share))   ::  interface
    ++  lime  $%  [%sole-effect sole-effect]            ::  :sole update
                  [%octo-game game]                     ::  :octo update
              ==                                        ::
    ++  move  (pair bone card)                          ::  cause and action
    ++  pear  ,[%octo-action action]                    ::  outgoing move
    ++  tube  (unit serf)                               ::  alive, remote
    --                                                  ::
=>  |%                                                  ::  historical state
    ++  axon     $%([%1 axle] [%0 axle-0])              ::
    ++  axle-0  ,[eye=face gam=game-0]                  ::
    ++  game-0  ,[who=? box=board boo=board]            ::
    --                                                  ::
=>  |%                                                  ::  parsers
    ++  colm  (cook |=(a=@ (sub a '1')) (shim '1' '3')) ::  row or column
    ++  come  ;~(plug colm ;~(pfix fas colm))           ::  coordinate
    ++  comb  (pick come ;~(pfix sig (punt fed:ag)))    ::  all command input
    ++  cope  |=(? ?:(+< (stag %| (cold ~ sig)) comb))  ::  with wait mode
    --                                                  ::
|_  [hid=hide moz=(list move) [%1 axle]]                ::  per server
++  et                                                  ::
  |_  [from say=sole-share]                             ::  per console client
  ++  abet  +>(q.eye (~(put by q.eye) ost say))         ::  continue
  ++  amok  +>(q.eye (~(del by q.eye) ost))             ::  discontinue
  ++  beep  (emit %bel ~)                               ::  bad user
  ++  cusp  (cope wait)                                 ::  parsing rule
  ++  delt  |=  cal=sole-change                         ::  input line change
            =^  cul  say  (remit:sole cal good)         ::
            ?~  cul  (park:abet(p.eye buf.say) | ~)     ::
            abet:beep:(emit det/u.cul)                  ::
  ++  emit  |=  fec=sole-effect  ^+  +>                 ::  send effect
            +>(moz [[ost %diff %sole-effect fec] moz])  ::  
  ++  emil  |=  fex=(list sole-effect)                  ::  send effects
            ?~(fex +> $(fex t.fex, +> (emit i.fex)))    ::
  ++  good  |=((list ,@c) -:(rose (tufa +<) cusp))      ::  valid input
  ++  here  ~(. go [src gam])                           ::  game core
  ++  kick  |=  point                                   ::  move command
            =^  dud  gam  ~(m at:here +<)               ::
            ?.  dud  abet:beep  =+  mus=res:here        ::
            (park:abet(gam ?^(mus *game gam)) %2 mus)   ::
  ++  line  =^  cal  say  (transmit:sole set/p.eye)     ::  update command
            (emit %det cal)                             ::
  ++  make  =+  dur=(rust (tufa p.eye) comb)            ::
            ?~  dur  abet:beep                          ::
            =.  +  line(p.eye ~)                        ::
            ?-(+<.dur & (kick +>.dur), | (plan +>.dur)) ::
  ++  mean  |=((unit tape) ?~(+< +> (emit txt/+<+)))    ::  optional message
  ++  play  |=  lev=?(%0 %1 %2)                         ::  update by level
            ?-(lev %0 +>, %1 line, %2 line:show:prom)   ::
  ++  plow  |=  [lev=?(%0 %1 %2) mus=(unit tape)]       ::  complete print
            abet:(mean:(play lev) mus)                  ::
  ++  prom  %^  emit  %pro  %&  :-  %octo               ::  update prompt
            ?:  wait  "(their turn) "                   ::
            ": {~[(icon who.gam)]} to move (row/col): " ::  
  ++  plan  |=  mut=(unit serf)                         ::  peer command
            ?~  mut  ?~(but abet:beep stop:abet)        ::
            ?^(but abet:beep (link:abet u.mut))         ::
  ++  rend  (turn tab:here |=(tape txt/+<))             ::  table print
  ++  show  (emit %mor rend)                            ::  update board
  ++  sole  ~(. cs say)                                 ::  console core
  ++  wait  &(?=(^ but) !=(q.q.u.but who.gam))          ::  waiting turn
  ++  work  |=  act=sole-action                         ::  console input
            ?:(?=(%det -.act) (delt +.act) make)        ::
  --                                                    ::
++  abet  [(flop moz) .(moz ~)]                         ::  resolve core
++  dump  |=(mov=move %_(+> moz [mov moz]))             ::  send move
++  dish  |=(cad=card (dump 0 cad))                     ::  forward move
++  flet  |=(from ~(. et +< (~(got by q.eye) ost)))     ::  in old client
++  fret  |=(from ~(. et +< *sole-share))               ::  in new client
++  like  |=(a=ship |*(* [/octo [a %octo] +<]))         ::  to friend
++  link  |=  mot=serf  %+  dish(but `[| mot])  %peer   ::  subscribe to friend
          ((like p.mot) /octo/net/[?:(q.mot %x %o)])    ::  
++  pals  %+  turn  (pale hid (prix /sole))  |=  sink   ::  per console 
          [[p=p.+< q=q.+<] r=(~(got by q.eye) p.+<)]    ::
++  park  |=  [lev=?(%0 %1 %2) mus=(unit tape)]         ::  update all
          =.  +>  ?:(=(%2 lev) push +>)                 ::  
          =+  pals                                      ::
          |-  ^+  +>.^$  ?~  +<  +>.^$                  ::
          $(+< t.+<, +>.^$ (~(plow et i.+<) lev mus))   ::
++  push  =+  pey=(pale hid (prix /octo))  |-  ^+  +>   ::  update friends
          ?~(pey +> $(pey t.pey, +> (sell p.i.pey)))    ::
++  sell  |=(ost=bone (dump ost %diff %octo-game gam))  ::  update friend
++  stop  (dish(but ~) pull/((like +>-.but) ~))         ::  cancel subscribe
::                                                      ::  ::
::::                                                    ::  ::  handlers
  ::                                                    ::  ::
++  coup-octo                                           ::  move acknowledge
          |=  [then saw=(unit tang)]  =<  abet          ::
          ?~(saw +> (park %0 `"move failed"))           ::
++  diff-octo-game                                      ::  friend update
          |=  [then gam=game]  =<  abet                 ::
          ?.  &(?=([~ %& *] but) =(src p.q.u.but))  +>  ::
          ?:  =(^gam gam)  +>                           ::
          (park(gam gam) %2 ~)                          ::
++  peer-sole                                           ::  console subscribe
          |=  [from pax=path]  =<  abet                 ::
          (plow:(fret +<-) %2 ~)                        ::
++  poke-sole-action                                    ::  console input
          |=  [from act=sole-action]  =<  abet          ::
          (work:(flet +<-) act)                         ::
++  poke-octo-move                                      ::
          |=  [from wha=point]  =<  abet                ::
          =^  dud  gam  ~(m at:here wha)                ::
          ?>  dud  =+  mus=res:here                     ::
          (park(gam ?^(mus *game gam)) %2 mus)          ::
++  prep  |=  [from old=(unit ,[(list move) axon])]     ::  initialize
          =<  abet  ?~  old  +>                         ::
          =<  (park %2 ~)                               ::
          ?-  -.+>.old                                  ::
            %1  +>(+<+ u.old)                           ::
            %0  +>(eye.+< eye.+>.old, gam.+< gam.+>.old)::
          ==                                            ::
++  pull-octo                                           ::
          |=  [from *]  =<  abet                        ::
          (park(but ~) %2 `"dropped")                   ::
++  pull-sole                                           ::  disconnect console
          |=  [from *]  =<  abet                        ::
          amok:(flet +<-)                               ::
++  quit-octo                                           ::  unlinked by friend
          |=([then ~] abet:(park(but ~) %0 `"removed")) ::
++  reap-octo                                           ::  linked to friend
          |=  [then saw=(unit tang)]  =<  abet          ::
          ?>  ?=([~ %| *] but)                          ::
          ?^  saw  (park:stop %0 `"fail to {<src>}")    ::
          (park(p.u.but %&) %0 `"link to {<src>}")      ::
--
