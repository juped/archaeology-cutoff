---
title: Hoon 101.5: from mold to span
sort: 5
next: false
---
# Hoon 101.5: from mold to span

In [chapter 0](0-nouns), we read about nouns.  In [chapter 1](1-twigs), 
we discovered twigs and legs.  In [chapter 2](2-syntax), we learned 
Hoon syntax and created our first source file.  In [chapter 3](3-algorithm) 
we wrote an actual algorithm.  And in [chapter 4](4-function) we
went so far as to define a function.

Now we'll go crazy and build some actual *data structures*.

## How to use this tutorial

Ideally, you've installed an Urbit planet (if you have a ticket)
or comet (if you don't).  See the [user doc](../../../user).

We recommend opening up the dojo and just typing the examples;
you don't know a language until you know it in your fingers.
Also, make sure you've worked through the chapters in order.

## Goal: practical data structures

Having built functions, our next goal is *data structures*.  We
know this involves molds and spans, somehow.  We'd like to
actually put our data structures in structure files our build
system can use, as though we were really writing a programs.

## Form of the solution: books and reef

Our solution comes in a new subspecies of core: the *book*.

If a gate is a function, a book is a library.  (Saying "library"
instead of "book" is even more inaccurate than calling a gate a
"function", but people will do it.)  A book is just a core which 
pushes no payload data and can have any arms it wants.

> Cores earn these labels by their payload geometry and/or
battery constraints.  A *gate* has payload geometry `[sample
context]` and a one-arm battery, `$`.  A *book* has no payload
geometry or battery constraints.  A core with a payload `[sample
context]`, but no battery constraints, is a *door*.  A core with
no payload geometry, but a one-arm battery `$`, is a *trap*.

A conventional Hoon subject, which does the job carried out by an
scope, environment or context, is a big stack of books called a
*reef*.  Each book's payload is the book above it.  Outer code
can use inner code, but not of course the reverse.

There are many ways to assemble a reef of books, but written
straight out in one file, with the simplest possible runes:
```
=>  zero=0
=>  |%
    ++  one  zero
    --
=>  |%
    ++  two  +(one)
    --
|%
++  tri  +(two)
--
```
This produces a core noun that looks like:
```
[tri-battery two-battery one-battery zero=0]
```

## Reef structures

When we build user-level code in practice, we use the Arvo build
system `%ford` (which also built our generator in the last
chapter).

The user-level reef you get in `%ford` contains, in order: the
Hoon system (the basic books we need to build the compiler, then
the compiler, then all the standard books we don't need to build
the compiler but should be bundled in Arvo); then, a book of
data structures; then, a book of libraries.

System-level arms are naked -- you don't write `(dec:system 42)`
to decrement `42`, you write `(dec 42)`.  But user-level books,
for both libraries and structures, are actually books of books.
Your structure book is shaped like:
```
|%  
++  book-one
  |%
  ++  one  0
  --
++  book-two
  |%
  ++  two  +(one:book-one)
  --
++  book-tri
  |%
  ++  tri  +(two:book-two)
  --
--
```
Since this chapter is about molds, we'll be installing and
loading a structure file, containing a single structure book.
You can even think of this as an "include file" if you like.

A structure book named `/test`, in the `%sandbox` desk, goes in
`/=sandbox=/sur/test/hoon`.  In Unix, this will be
`tasfyn-partyv/sur/test.hoon`, as soon as you mount `%sur`:
```
~tasfyn-partyv:dojo/sandbox> |mount /===/sur %sur
```
Let's do everything properly this time.  At the top of the file, 
put the standard Hoon block-comment header:
```
::                                                      ::  ::
::::  /hoon/test/sur                                    ::::::  test structures
  ::                                                    ::  ::
```
> Nothing in these lines is parsed, of course.  But its presence
and standard form shows the reader you care about writing tight,
pro-quality Hoon.  Its absence shows the opposite -- which may
be perfectly fine.  (Why is the path backward?  Because it is.
The stylized N at column 0 is for Nock; the H at 57 is for Hoon.
Apparently it's called "branding" and is still done to cows.)

After this decorative header, our file is just the book itself.
There is no more boilerplate.
```
|%
++  welcome  ,[%hello %world]
--
```
> Hoon can become quite gnarly, but only if you're doing
something wrong.  If your Hoon gets gnarly, you are either
choosing the wrong solution or solving the wrong problem.
Normal code should be quite pretty.

## Loading a structure file

We've created a tiny, tasteful little structure book.  Let's fire
it up.  At the dojo prompt:
```
~tasfyn-partyv:dojo/sandbox> =+sur /test
```
This puts our `test` book into the structure book that the dojo
uses when it builds each and every command line.
```
~tasfyn-partyv:dojo/sandbox> *welcome:test
  [%hello %world]
```
You've just built and used your first mold.

## Types in Hoon: span and mold revisited

While Hoon is a higher-order typed functional language like
Haskell, its type system works on very different principles
than Haskell's.  Or Java's.  Or any normal language's.

One concept in a normal language, the *type*, becomes two quite
categorically different concepts in Hoon, the *mold* and *span*.

> This blatant complication appears to violate Occam's razor.
But Einstein, who was based, said: everything must be as simple
as possible, but no simpler.  Also, once you've seen the
difference between a mold and a span, it's hard to unsee it.

Spans we've already done a lot of work with.  What is a span?  We
know the answer now: a *semantically annotated set of nouns*.

Whereas a mold is a *constructive definition of noun geometry*.
It's easy to see how in most languages, these are synonyms.

## Intuitive molds

"A mold is a constructive definition of a noun geometry."  Let's
make this sentence make sense.

A mold, like a span, defines a noun geometry.  The mold expresses
its semantics by expanding itself to a twig that, applied to an
arbitrary subject, produces a noun within the geometry.

The molded twig is a *normalizer*.  If its subject is within its
range, it produces its own subject.  In math notation, `f(f(x))
== f(x)`.

For example, consider one simple shape: a pair of atoms.  A
normalizer for this shape is:
```
?:(.?(+1) [0 0] [?:(.?(+2) 0 +2) ?:(.?(+3) 0 +3)])
```
If the subject is a pair of atoms, the product is the subject.
Otherwise, we apply `0` as necessary to produce a pair of atoms.
(A normalizer can also crash on bad input instead of fixing it.)

So molds construct twigs.  Then twig compilation maps `[span
twig]`, the subject set and the source expression, to `[span
nock]`, the product set and Nock formula.

Not only are molds and spans categorically different, they never
even touch each other.  Molds are a macro system; spans are an
inference engine.

So a mold is a constructive definition of a noun geometry,
because it constructs a twig which applies its geometry.  Does
this make more sense now?

## Deeper into molds

Molds are a beautiful thing in principle.  But we have to admit
that mold syntax and naming are the gnarliest corners of Hoon.
(Of course, that's only because the rest is so chic.) 

The previous section is a correct, but abstract, definition of a
mold.  The truth about molds is that we use them to generate two
more specific twigs: the `bunt` and the `clam`.

> We apologize again for these atrocious names.  In particular,
nothing smells worse than a rotten clam.

The `bunt` of a mold is a twig that produces a default noun
(hopefully, but not always, constant) in the mold geometry.

The `clam` of a mold is a twig that produces a gate, whose sample
is any noun, and whose product is in the mold geometry.

In our example above, we bunted with the syntax `*welcome:test`.
(Regular form: `$*($^(welcome:test))`.)  This twig produced the
only noun, `[%hello %world]`, in the geometry.

But `++welcome` itself is defined as `,[%hello %world]`.
(Regular form: `$,($:(%hello %world))`.)  This twig produces a
gate whose product is always `[%hello %world]`:
```
~tasfyn-partyv:dojo/sandbox> (welcome:test ~)
[%hello %world]
~tasfyn-partyv:dojo/sandbox> (welcome:test %hello %world)
[%hello %world]
~tasfyn-partyv:dojo/sandbox> (welcome:test %world %hello ~)
[%hello %world]
```

## The `mold` mold

You don't know all this syntax yet, but:
```
++  mold  $&  [p=mold q=mold]                     ::  ordered pair
          $%  [%axil p=base]                      ::  base type
              [%bark p=term q=mold]               ::  name
              [%bush p=mold q=mold]               ::  pair/tag
              [%fern p=[i=mold t=(list mold)]]    ::  plain selection
              [%herb p=twig]                      ::  gate
              [%kelp p=[i=line t=(list line)]]    ::  tag selection
              [%leaf p=term q=@]                  ::  constant atom
              [%reed p=mold q=mold]               ::  atom/cell
              [%weed p=twig]                      ::  example
          ==                                      ::
```
Although we use normal Hoon rune syntax to parse molds, we name
the mold stems not by the rune names `%tsls` style, but rather
with this strange herbaceous motif.

> Some think the only reason molds have wordy stems is to
prove what a bad idea it'd be to use this style for twigs.

---------------------UNMERGED-----------------


The mold's raw input is called its *pronoun*.  A twig computes
its product from its subject.  A mold rectifies its pronoun
(an arbitrary noun) into the *surnoun* (a well-shaped noun).

Here is the mold of `mold`.  We don't know all this syntax yet.
Let's try not to depend on features before we've defined them.
```
++  mold  $&  [p=mold q=mold]                     ::  ordered pair
          $%  [%axil p=base]                      ::  base type
              [%bark p=term q=mold]               ::  name
              [%bush p=mold q=mold]               ::  pair/tag
              [%cane p=mold q=mold]               ::
              [%fern p=[i=mold t=(list mold)]]    ::  plain selection
              [%herb p=twig]                      ::  gate
              [%kelp p=[i=line t=(list line)]]    ::  tag selection
              [%leaf p=@tas q=@]                  ::  constant atom
              [%reed p=mold q=mold]               ::  atom/cell
              [%weed p=twig]                      ::  example
          ==                                      ::
```



### `[%leaf p=@tas q=@]`: an atomic constant

A `%leaf` mold, like `%hello`, builds a constant atom.
`q` is the atom; `p` is the aura.

> Wait: isn't `%hello` also a twig?  Yes.  Since the parser knows
when it's parsing a twig or a mold, twig and mold syntax freely
overlaps.  When these syntaxes match, we try to make them mean
the same *abstract* concept, but they're still different things.

We already have a leaf in our test book, but let's add `%hello`
to it:
```
|%
++  hello    ,%hello
++  welcome  ,[hello %world]
--
```
Now we can use `hello` the way we used `welcome`:
```
~tasfyn-partyv:dojo/sandbox> *hello
  %hello
~tasfyn-partyv:dojo/sandbox> (hello 42)
  %hello
```
### `[p=mold q=mold]`: a parallel pair

Molds use the same geometric trick as twigs and Nock formulas:
binding pair semantics to a stemless bulb.  But mold and twig
pair semantics are very different.

In a twig pair, of course, head and tail use the same subject.
In a mold pair, the pronoun *splits in half*.  The head mold
rectifies the pronoun's head; the tail mold rectifies its tail.
If the pronoun is an atom, it's defaulted to `[0 0]`.

The regular syntax for a mold tuple is `$:(a b c)`, but the
irregular form is `[a b c]`, matching the twig syntax.  (The
regular form of a twig tuple is `:*(a b c)`.)

Let's modify our test book to use only regular forms:
```
|%
++  hello    $,  %hello
++  welcome  $,  $:(hello %world)
--
```
### `[%herb p=twig]`: gate as mold

Our test book is actually *almost* regular.  For complete
regularity, we need to use a very rare rune, `$^`:
```
|%
++  hello    $,  %hello
++  welcome  $,  $:($^(hello) %world)
--
```
The irregular form of `$^(hello)` is just `hello`.  When Hoon is
trying to parse a mold and fails, it tries to parse a twig
instead.  If that succeeds, it's wrapped in an invisible `$^` as
an `%herb`.  We only need to type the `$^` if our twig's syntax
actually parses as a mold, which is basically never.

How does an `%herb` work?  The twig `p` is a gate (a function).  To
produce the surnoun, we slam (call) `p` on the pronoun.

> When we use a twig as a mold, in both `%herb` and `%weed`,
what's the subject of the twig?  The same as the subject of the
twig rune, eg `$*` or `$,`, that we use the mold in.  In other
words, molds remain hygienic in the Lisp macro sense.

As we see, the relationship between twigs and molds can get quite
intricate, even when the code looks simple.  Let's expand our
test file to put arms, twigs and molds on separate lines:
```
|%                            ::  twig
++  hello                     ::  arm
             $,               ::  twig
               %hello         ::  mold
++  welcome                   ::  arm
             $,               ::  twig
               $:             ::  mold
                 $^           ::  mold
                   hello      ::  twig
                 %world       ::  mold
               ==
--
```
### `[%weed p=twig]`

`%weed` also uses a twig `p` as a mold.  But `p` in an `%herb` is
a rectifier; `p` in a twig is just an example.  To produce the
surnoun, we just apply `p`, ignoring the pronoun.

Just to be contrary, let's build `%world` as a weed.  The regular
syntax is `$_(%world)`; the irregular form is `_%world`.  We'll
add it to our regular test book:
```
|%                            ::  twig
++  hello                     ::  arm
             $,               ::  twig
               %hello         ::  mold
++  welcome                   ::  arm
             $,               ::  twig
               $:             ::  mold
                 $^           ::  mold
                   hello      ::  twig
                 $_           ::  mold
                   world      ::  twig
               ==             :: 
++  world                     ::  arm
            %world            ::  twig
--
```
Staring at this illustration for a few minutes might leave you
with a little more grounding on the twig-mold relationship.  The
same code, back in irregular form:
```
|%
++  hello    ,%hello
++  welcome  ,[hello _world]
++  world    %world
--
```
As the name implies, `%weed` is generally little disreputale.

###
