::    Console front-end
::
::::  /hook/hymn/fab/sole/pub
  ::
/?    310
|%
++  cdnj  |=(a=tape ;script(src "//cdnjs.cloudflare.com/ajax/libs/{a}");)
--
::
::::
  ::
^-  manx
;html
  ;head 
    ;title: Sole
    ;*  %-  turn  :_  cdnj  ^-  wall
        :~  "jquery/2.1.1/jquery.min.js"
            "mousetrap/1.4.6/mousetrap.js"
            "react/0.11.0/react.js"
        ==
    ;script(src "/~/at/main/lib/urb.js");
    ;script: urb.appl = 'dojo'
    ;style:'''
           #term {
             width: 100%;
           }
           #term * {
             margin: 0px;
           }
           '''
  ==
  ;body
    ;div#err;
    ;div#term:""
    ;script@"src/share.coffee"(type "text/coffeescript");
    ;script(type "text/coffeescript")  ;-  %-  trip
      '''
      [DOM,recl,rend] = [React.DOM, React.createClass, React.renderComponent]
      [div, pre, span] = [DOM.div, DOM.pre, DOM.span]
      str = JSON.stringify
      
      Prompt = recl render: ->
        [pro,cur,buf] = [@props.prompt, @props.cursor, @props.input + " "]
        pre {}, pro,
          span {style: background: 'lightgray'}, buf.slice(0,cur), "\u0332", buf.slice(cur)
        
      Matr = recl render: ->
        lines = @props.rows.slice().reverse().map (lin)-> pre {}, lin, " "
        lines.push Prompt {prompt:@props.prompt, input:@props.input, cursor:@props.cursor}
        div {}, lines
      
      $ ->
        termRev = 0
        pressed = []
        deltim = null

        met = $('<pre>').text('m').css(display: 'none').appendTo(term).width()
        subs = ""
        # $(window).resize -> 
        #   window.termWif = ($(term).width() / met).toFixed()
        #   path =  "/new/#{termWif}"
        #   if path is subs
        #     return
        #   if subs
        #     urb.unsubscribe path: subs
        #   subs = path
        #   urb.subscribe {path}, (err,dat)->
        #       if err or dat.data.ok
        #         return;
        #       syncRev = dat.data.rev
        #       unless termRev > syncRev
        #         termRev = syncRev
        #         matr.setProps rows: dat.data.stak
        #         document.title = "Matrix"  # XX  debug
        # $(window).resize()

        flash = ($el, background)->
          $el.css {background}
          if background
            setTimeout (-> flash $el,''), 50
            
        matr = rend (Matr rows:[], prompt:"", input:"", history:[], cursor:0), term
        update = (a) -> matr.setProps a
        buffer = new Share ""
        window.buffer = buffer
        sync = (ted)-> 
          update input: buffer.buf, cursor: buffer.transpose ted, matr.props.cursor
        
        peer = (ruh) ->
          if ruh.map then return ruh.map peer
          switch Object.keys(ruh)[0]
            when 'txt' then update rows: [ruh.txt, matr.props.rows...]
            when 'tan' then ruh.tan.split("\n").reverse().map (txt)-> peer {txt}
            when 'hop' then update cursor: buffer.transpose ruh.hop #; peer act:'bel'
            when 'pro' then update prompt: ruh.pro.cad
            when 'blk' then console.log "Stub #{str ruh}"
            when 'det' then buffer.receive ruh.det; sync ruh.det.ted
            when 'act' then switch ruh.act
              when 'clr' then update rows:[]
              when 'bel' then flash ($ 'body'), 'black'
              when 'nex' then update
                input: ""
                cursor: 1
                history: [matr.props.input, matr.props.history...]
            #   else throw "Unknown "+(JSON.stringify ruh)
            else v = Object.keys(ruh); console.log v, ruh[v[0]]
        
        urb.bind "/sole", {wire:"/"}, (err,d)->
          if err then console.log err
          else if d.data then peer d.data

        sendAction = (data)->
          urb.send {mark: 'sole-action', data}, (e,res)->
            if res.status isnt 200 then $('#err')[0].innerText = err.data.mess
        
        doEdit = (ted)->
          det = buffer.transmit ted
          sync ted
          sendAction {det}
        
        #later = (data)->
        #  if data
        #    pressed.push data
        #  clearTimeout deltim
        #  setTimeout (->
        #    if urb.reqq.length > 0 
        #      return deltim = later()
        #    urb.send data: pressed
        #    pressed = []
        #  ), 500

        Mousetrap.handleKey = (char, mod, e)->
          norm = {
            capslock:  'caps'
            pageup:    'pgup'
            pagedown:  'pgdn'
            backspace: 'baxp'
            enter:     'entr'
          }
          key = 
            if char.length is 1
              if e.type is 'keypress'
                str: char
            else if e.type is 'keydown'
              if char isnt 'space'
                act: norm[char] ? char
            else if e.type is 'keyup' and norm[key] is 'caps'
              act: 'uncap'
          if key
            e.preventDefault()
            curs = matr.props.cursor
            if key.str
              doEdit ins: cha: key.str, at: curs
              update cursor: curs+1
            switch key.act
              when 'entr' then sendAction 'ret'
              when 'left' then if curs > 0 
                update cursor: curs-1
              when 'right' then if curs < buffer.buf.length
                update cursor: curs+1
              when 'baxp' then doEdit del: curs-1
              else (if key.act then console.log key.act)
                
            # amod = (arr)->
            #   for i in arr
            #     unless mod.indexOf(i) < 0
            #       return yes
            #   no
            # if key.str or key.act is 'baxp' or key.act is 'entr'
            #   termRev++
            #   [bot, rest...] = old = matr.props.rows
            #   matr.setProps rows:(
            #     switch  key.act 
            #       when 'baxp'
            #         if amod ['ctrl', 'meta']
            #           ['', rest...]
            #         else if amod ['alt']
            #           [(bot.replace /\ *[^ ]*$/, ''), rest...]
            #         else if bot and bot.length 
            #           [bot.slice(0, -1), rest...]
            #         else if rest[0] and rest[0].length
            #           res = rest.slice()
            #           res[0] = res[0].slice(0, -1)
            #           res
            #         else rest
            #       when 'entr'
            #         ['', old...]
            #       when undefined
            #         if mod.length > 1 or (mod.length and !amod ['shift'])
            #           old
            #         else unless old and bot isnt null
            #           [key.str]
            #         #else if bot.length is termWif
            #         #  [key.str, old...]
            #         else [bot + key.str, rest...]
            #   )
            #   document.title = "Matri"  # XX  debug
            # later {mod, key}


      '''
    ==
    ;+  (cdnj "coffee-script/1.7.1/coffee-script.min.js")
==  ==
