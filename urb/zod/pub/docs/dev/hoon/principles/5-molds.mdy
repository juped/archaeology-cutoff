---
title: Hoon 101.5: from mold to span
sort: 5
next: false
---
# Hoon 101.5: from mold to span

In [chapter 0](0-nouns), we read about nouns.  In [chapter 1](1-twigs), 
we discovered twigs and legs.  In [chapter 2](2-syntax), we learned 
Hoon syntax and created our first source file.  In [chapter 3](3-algorithm) 
we wrote an actual algorithm.  And in [chapter 4](4-function) we
went so far as to define a function.

Now we'll go crazy and build some actual *data structures*.

## How to use this tutorial

Ideally, you've installed an Urbit planet (if you have a ticket)
or comet (if you don't).  See the [user doc](../../../user).

We recommend opening up the dojo and just typing the examples;
you don't know a language until you know it in your fingers.
Also, make sure you've worked through the chapters in order.

## Goal: practical data structures

Having built functions, our next goal is *data structures*.  We
know this involves molds and spans, somehow.  We'd like to
actually put our data structures in structure files our build
system can use, as though we were really writing a programs.

## Form of the solution: books and reef

Our solution comes in a new subspecies of core: the *book*.  If a
gate is a sort of function, a book is a sort of library.  In the 

> Cores earn their labels by their payload geometry and/or
battery constraints.  A *gate* has payload geometry `[sample
context]` and a one-arm battery, `$`.  A *book* has no payload
geometry or battery constraints.  A core with a payload `[sample
context]`, but no battery constraints, is a *door*.  A core with
no payload geometry, but a one-arm battery `$`, is a *trap*.

A conventional Hoon subject, which does the job carried out by an
scope, environment or context, is a big stack of books called a
*reef*.  Each book's payload is the book above it.  Outer code
can use inner code, but not of course the reverse.

There are many ways to assemble a reef of books, but written
straight out in one file, with the simplest possible runes:
```
=>  zero=0
=>  |%
    ++  one  zero
    --
=>  |%
    ++  two  +(one)
    --
|%
++  tri  +(two)
--
```
This produces a reef that looks like:
```
[tri-battery two-battery one-battery zero=0]
```
Obviously, from the third book you can use arms in all three
books.  In the second book you can use the second and first.
In the first you can only use the first.

## Reef structure and meta-books

When we build user-level code in practice, we use the Arvo build
system `%ford` (which also built our generator in the last
chapter).

The user-level reef you get in `%ford` contains, in order: the
Hoon system (the books that we need to build the compiler; then
the compiler; then the books that we don't need to build the
compiler, but everyone should still have); then, a meta-book of
user-level data structures; then, a meta-book of user-level
algorithms.

A meta-book is just a book whose arms produce books.  System arms
are naked.  You don't write `(dec:system 42)` to decrement `42`,
you write `(dec 42)`.  But user-level books, for both libraries
and structures, are actually books of books.  Your user-level
structure book is shaped like: 
``` 
|%  
++  book-one
  |%
  ++  one  0
  --
++  book-two
  |%
  ++  two  +(one:book-one)
  --
++  book-tri
  |%
  ++  tri  +(two:book-two)
  --
--
```
Since this chapter is about molds, we'll be installing and
loading a structure file, containing a single structure book.
You can even think of this as an "include file" if you like.

A structure book named `/test`, in the `%sandbox` desk, goes in
`/=sandbox=/sur/test/hoon`.  In Unix, this will be
`tasfyn-partyv/sur/test.hoon`, as soon as you mount `%sur`:
```
~tasfyn-partyv:dojo/sandbox> |mount /===/sur %sur
```
Let's do everything properly this time.  At the top of the file, 
put the standard Hoon block-comment header:
```
::                                                      ::  ::
::::  /hoon/test/sur                                    ::::::  test structures
  ::                                                    ::  ::
```
> Nothing in this header is parsed, of course.  But its presence
and standard form shows the reader you care about writing tight,
pro-quality Hoon.  Its absence shows the opposite -- which may
be perfectly fine.  (Why is the path backward?  Because it is.
The stylized N at column 0 is for Nock; the H at 57 for Hoon.)

After this decorative header, our file is just the book itself.
There is no further boilerplate.
```
|%
++  welcome  ,[%hello %world]
--
```

## Loading a structure file

We've created a tiny, tasteful little structure book.  Let's fire
it up.  At the dojo prompt:
```
~tasfyn-partyv:dojo/sandbox> =+sur /test
```
This puts our `test` book into the structure book that the dojo
uses when it builds each and every command line.
```
~tasfyn-partyv:dojo/sandbox> *welcome:test
  [%hello %world]
```
You've just built and used your first mold.  But wait, what are
we doing here?

## Types in Hoon: span and mold revisited

While Hoon is a higher-order typed functional language like
Haskell, its type system works on very different principles
than Haskell's.  Or Java's.  Or any normal language's.

One concept in a normal language, the *type*, becomes two quite
different concepts in Hoon, the *mold* and *span*.

Spans we've already done a lot of work with.  What is a span?  We
know the answer now: a *semantically annotated set of nouns*.

Whereas a mold is a *constructive definition of noun geometry*.
It's easy to see how in most languages, these are synonyms.  But
in Hoon, a mold is a way to make a noun; a span is a way to
describe the noun you've made.

## Intuitive molds

"A mold is a constructive definition of a noun geometry."  Let's
make this sentence make sense.

A mold, like a span, defines a noun geometry.  The mold expresses
its semantics by expanding itself to a twig that, applied to an
arbitrary subject, produces a correctly-shaped noun.

The molded twig is a *normalizer*.  If its subject is within its
range, it produces its own subject.  In math notation, `f(f(x))
== f(x)`.  If its subject is out of range, it makes a default.

For example, consider one simple shape: a pair of atoms.  A
normalizer for this shape is:
```
?:(.?(+1) [0 0] [?:(.?(+2) 0 +2) ?:(.?(+3) 0 +3)])
```
If the subject is a pair of atoms, the product is the subject.
Otherwise, we default as necessary to produce a pair of atoms.

So molds construct twigs.  Then twig compilation maps `[span
twig]`, the subject set and the source expression, to `[span
nock]`, the product set and Nock formula.

Not only are molds and spans categorically different, they never
even touch each other.  Molds are a macro system; spans are an
inference engine.  The span engine (`ut`) has no idea whether or
not molds were involved in the assembly of the 

So a mold is a constructive definition of a noun geometry,
because it constructs a twig which applies its geometry.  Does
this make more sense now?

## Molds as twigs

Is a mold a twig?  If not, how do we put it in a Hoon file?

A mold is not a twig, though it uses twig-like syntax.  We wrap
it in a twig in one of two ways: a `bunt` or a `clam`.

The `bunt` of a mold is a twig that produces a default noun
(hopefully, but not always, constant) in the mold geometry.
The regular bunt form is `$*(mold)`; irregular form, `*mold`.

The `clam` of a mold is a twig that produces a gate, whose sample
is any noun, and whose product is in the mold geometry.  The
regular clam form is `$,(mold)`; irregular form, `,mold`.

It's easy to get from normalizer to bunt: just normalize nil,
`~`.  It's easy to get from normalizer to clam: just make a gate
whose sample is `*`, any noun, and normalize the sample.

## The mold for molds

Obviously, this uses mold syntax that we haven't explained yet,
but here's 
Now that you're thoroughly frightened, let's go through our molds
one by one and 

```
++  base  ?([%atom p=%] %noun %cell %bean %null)     ::  axils, @ * ^ ? ~
++  line  ,[p=[%leaf p=@tas q=@] q=tile]          ::  %kelp case
++  mold  $&  [p=mold q=mold]                     ::  ordered pair
          $%  [%axil p=base]                      ::  base type
              [%bark p=term q=mold]               ::  name
              [%bush p=mold q=mold]               ::  pair/tag
              [%fern p=[i=mold t=(list mold)]]    ::  plain selection
              [%herb p=twig]                      ::  gate
              [%kelp p=[i=line t=(list line)]]    ::  tag selection
              [%leaf p=term q=@]                  ::  constant atom
              [%reed p=mold q=mold]               ::  atom/cell
              [%weed p=twig]                      ::  example
          ==                                      ::
```
Although we use normal Hoon rune syntax to parse molds, we name
the mold stems with this herbal theme, not condensed rune names.

## Understanding our example

Currently in `sur/test/hoon` we have:
```
|%
++  welcome  ,[%hello %world]
--
```


Molds are a beautiful thing in principle.  But we have to admit
that mold syntax and naming are the gnarliest corners of Hoon.
(Of course, that's only because the rest is so elegant.) 

The previous section is a correct, but abstract, definition of a
mold.  The truth about molds is that we use them to generate two
more specific twigs: the `bunt` and the `clam`.

> We apologize again for these atrocious names.  In particular,
nothing smells worse than a rotten clam.

In our example above, we bunted with the syntax `*welcome:test`.
(Regular form: `$*($^(welcome:test))`.)  This twig produced the
only noun, `[%hello %world]`, in the geometry.

But `++welcome` itself is defined as `,[%hello %world]`.
(Regular form: `$,($:(%hello %world))`.)  This twig produces a
gate whose product is always `[%hello %world]`:
```
~tasfyn-partyv:dojo/sandbox> (welcome:test ~)
[%hello %world]
~tasfyn-partyv:dojo/sandbox> (welcome:test %hello %world)
[%hello %world]
~tasfyn-partyv:dojo/sandbox> (welcome:test %world %hello ~)
[%hello %world]
```

## Twigs and molds: a complicated relationship

Alas, we've misled you a little in our definition of a twig.

You may have thought twigs were a homogeneously recursive tree.
Different stems may have different fanout in their bulbs, like
the difference between `[%tsls p=twig q=twig]` and `[%cltr
p=(list twig)]`, but at least everything repeated was a twig.

Not so.  Some twigs contain molds, like `[%wtts p=mold q=twig]`.
Some molds contain twigs, like `[%weed p=twig]`.  It's a regular
rainforest out there.  In this jungle, Hoon's syntax has to be
optimized for prettiness rather than clarity, a mistake we don't
like to make.  Some confusion is the inevitable consequence.

For example, look at `,[%hello %world]`.  This is a twig, whose
simplest regular form is `$,([%hello %world])`.  `$,` is a twig
`[%bccm p=mold]`; it produces the clam of `p`.

So in this context, `[%hello %world]` is a mold.  It's an
irregular form of the mold `$:(%hello %world)`, which parses to
`[[%leaf %tas %hello] [%leaf %tas %world]]`.

This same syntax, `[%hello %world]`, is perfectly good *twig*
syntax.  So it's easy to write `[%hello %world]` instead of
`,[%hello %world]`.  They're both twigs, but *different* twigs.

When we write `*welcome:test`, or formally `$*(welcome:test)`, 
again we write a twig: `[%bctr p=mold]`.  So `welcome:test` is a
mold?  We thought it was a twig?  It's both, and this time it
means the *same* thing.

When you use a twig where a mold belongs, the parser assumes your
twig is a normalizing gate.  It automatically inserts the `%herb`
stem, `$^`.  Again, the full regular syntax: `$*($^(welcome:test))`.

Of course, `welcome:test` *is* a normalizing gate.  Because the
`welcome` arm produces a clam `$,`, which as we just saw makes
the mold `[%hello %world]` into a normalizing gate.  So it's all
good, really.  But it's pretty confusing for two lines of code!

It's easy to focus on these conundrums and get even more
confused.  But molds are the most confusing aspect of Hoon, and
the twig-mold relationship is the most confusing aspect of molds.
And honestly, it's really not that difficult.

## The `mold` mold

Now that you're thoroughly frightened, let's go through our molds
one by one and

```
++  line  ,[p=[%leaf p=@tas q=@] q=tile]          ::  %kelp case
++  mold  $&  [p=mold q=mold]                     ::  ordered pair
          $%  [%axil p=base]                      ::  base type
              [%bark p=term q=mold]               ::  name
              [%bush p=mold q=mold]               ::  pair/tag
              [%fern p=[i=mold t=(list mold)]]    ::  plain selection
              [%herb p=twig]                      ::  gate
              [%kelp p=[i=line t=(list line)]]    ::  tag selection
              [%leaf p=term q=@]                  ::  constant atom
              [%reed p=mold q=mold]               ::  atom/cell
              [%weed p=twig]                      ::  example
          ==                                      ::
```
Although we use normal Hoon rune syntax to parse molds, we name
the mold stems not by the rune names `%tsls` style, but rather
with this strange herbaceous motif.

> Some think the only reason molds have wordy stems is to
show what a bad idea it'd be to do the same for twigs.

## Molds, one by one

Let's go through our molds one by one and build 
